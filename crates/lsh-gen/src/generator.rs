// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

use super::*;

pub struct Generator<'a> {
    compiler: Compiler<'a>,
}

impl<'a> Generator<'a> {
    pub fn new(arena: &'a Arena) -> Self {
        Self { compiler: Compiler::new(arena) }
    }

    pub fn add_file(&mut self, path: &Path) -> CompileResult<()> {
        let src = std::fs::read_to_string(path).map_err(|e| CompileError {
            line: 0,
            column: 0,
            message: format!("Failed to read {}: {}", path.display(), e),
        })?;
        self.compiler.parse(&src)
    }

    pub fn generate_rust(mut self) -> CompileResult<String> {
        self.compiler.optimize();
        let assembly = self.compiler.assemble()?;
        let mermaid = self.compiler.as_mermaid();

        let mut output = String::new();

        output.push_str(
            "\
// This file is generated by build.rs. Do not edit it manually.

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HighlightKind {
    Black,
    Red,
    Green,
    Yellow,
    Blue,
    Magenta,
    Cyan,
    White,
    BrightBlack,
    BrightRed,
    BrightGreen,
    BrightYellow,
    BrightBlue,
    BrightMagenta,
    BrightCyan,
    BrightWhite,

    Other,
    Comment,
    Number,
    String,
    Variable,
    Operator,
    Keyword,
    Method,
}

impl HighlightKind {
    #[inline]
    pub const fn as_usize(self) -> usize {
        unsafe { std::mem::transmute::<Self, u8>(self) as usize }
    }

    /// # Safety
    /// Don't pass the wrong thing you dummy.
    #[inline]
    pub const unsafe fn from_usize(value: usize) -> Self {
        debug_assert!(value <= Self::Method.as_usize());
        unsafe { std::mem::transmute::<u8, Self>(value as u8) }
    }
}

#[repr(C)]
#[derive(Default, Clone, Copy)]
pub struct Registers {
    pub zero: u32, // Zero
    pub pc: u32,   // ProgramCounter
    pub off: u32,  // InputOffset
    pub hs: u32,   // HighlightStart
    pub hk: u32,   // HighlightKind
}

/**
",
        );

        output.push_str(&mermaid);

        _ = write!(
            output,
            "\
**/
#[rustfmt::skip] pub const ASSEMBLY: [u32; {len}] = [
",
            len = assembly.instructions.len(),
        );

        let line_num_width = assembly.instructions.len().ilog10() as usize + 1;
        for (i, op) in assembly.instructions.iter().enumerate() {
            _ = writeln!(
                output,
                "        {op:#010x}, // {i:>line_num_width$}:  {mnemonic}",
                op = op.encode(),
                mnemonic = op.mnemonic()
            );
        }

        _ = write!(
            output,
            "\
];

#[rustfmt::skip] pub const CHARSETS: [[u16; 16]; {len}] = [
",
            len = assembly.charsets.len(),
        );

        for cs in assembly.charsets {
            output.push_str("    [");
            for lo in 0..16 {
                if lo > 0 {
                    output.push_str(", ");
                }
                let mut u = 0u16;
                for hi in 0..16 {
                    u |= (cs[hi * 16 + lo] as u16) << hi;
                }
                _ = write!(output, "0x{u:04x}");
            }
            output.push_str("],\n");
        }

        _ = write!(
            output,
            "\
];

#[rustfmt::skip] pub const STRINGS: [&str; {len}] = [
",
            len = assembly.strings.len(),
        );

        for s in assembly.strings {
            _ = writeln!(output, "    {s:?},");
        }

        output.push_str("];\n");

        Ok(output)
    }
}
