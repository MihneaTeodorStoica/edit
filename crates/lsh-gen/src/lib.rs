// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

//! This file takes a [`LanguageDefinition`] which describes syntax highlighting rules
//! for a language via a list of regular expressions that result in
//! * a highlight kind (comment, string, number, etc.)
//! * a push/pop action of another state (allows for nesting languages, such as in Markdown)
//!
//! It then transforms the definition into a list of [`WipState`], which are directions
//! to our custom DFA engine. The engine is very simple to reduce binary size.
//! Each defined state represents a root. Each additional state represents one step in
//! the regular expression. The difference between the two is that the root states will
//! seek to the next possible occurrence of any of the defined regular expressions,
//! whereas the additional states will try to match the next character without seeking.
//! If it doesn't match, it will fall back to the next possible defined regular expression.

#![feature(allocator_api)]
#![allow(irrefutable_let_patterns, unused, clippy::upper_case_acronyms)]

mod compiler;
mod definitions;

use std::fmt::Write as _;

use compiler::*;
use stdext::arena::scratch_arena;

const SRC: &str = include_str!("../../../lsh/COMMIT_EDITMSG.lsh");

pub fn generate() -> CompileResult<String> {
    let arena = scratch_arena(None);

    let mut compiler = Compiler::new(&arena);
    compiler.parse(SRC)?;
    compiler.optimize();
    let assembly = compiler.assemble()?;
    let mermaid = compiler.as_mermaid();

    let mut output = String::new();

    output.push_str(
        "\
// This file is generated by build.rs. Do not edit it manually.

pub struct Language {
    pub name: &'static str,
    pub filenames: &'static [&'static str],
    pub strings: &'static [&'static str],
    pub charsets: &'static [[u16; 16]],
    pub instructions: &'static [u32],
}

impl PartialEq for Language {
    fn eq(&self, other: &Self) -> bool {
        std::ptr::eq(self, other)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum HighlightKind {
    Black,
    Red,
    Green,
    Yellow,
    Blue,
    Magenta,
    Cyan,
    White,
    BrightBlack,
    BrightRed,
    BrightGreen,
    BrightYellow,
    BrightBlue,
    BrightMagenta,
    BrightCyan,
    BrightWhite,

    Other,
    Comment,
    Number,
    String,
    Variable,
    Operator,
    Keyword,
    Method,
}

impl HighlightKind {
    #[inline]
    pub const fn as_usize(self) -> usize {
        unsafe { std::mem::transmute::<HighlightKind, u8>(self) as usize }
    }

    /// # Safety
    /// Don't pass the wrong thing you dummy.
    #[inline]
    pub const unsafe fn from_usize(value: usize) -> Self {
        debug_assert!(value <= Self::Method.as_usize());
        unsafe { std::mem::transmute::<u8, HighlightKind>(value as u8) }
    }
}

#[repr(C)]
#[derive(Default, Clone, Copy)]
pub struct Registers {
    pub zero: u32, // Zero
    pub pc: u32,   // ProgramCounter
    pub ps: u32,   // ProcedureStart
    pub off: u32,  // InputOffset
    pub hs: u32,   // HighlightStart
    pub hk: u32,   // HighlightKind
}

/**
",
    );

    output.push_str(&mermaid);

    _ = write!(
        output,
        "\
**/
#[rustfmt::skip] pub const ASSEMBLY: [u32; {len}] = [
",
        len = assembly.instructions.len(),
    );

    let line_num_width = assembly.instructions.len().ilog10() as usize + 1;
    for (i, op) in assembly.instructions.iter().enumerate() {
        _ = writeln!(
            output,
            "        {op:#010x}, // {i:>line_num_width$}:  {mnemonic}",
            op = op.encode(),
            mnemonic = op.mnemonic()
        );
    }

    _ = write!(
        output,
        "\
];

#[rustfmt::skip] pub const CHARSETS: [[u16; 16]; {len}] = [
",
        len = assembly.charsets.len(),
    );

    for cs in assembly.charsets {
        output.push_str("    [");
        for lo in 0..16 {
            if lo > 0 {
                output.push_str(", ");
            }
            let mut u = 0u16;
            for hi in 0..16 {
                u |= (cs[hi * 16 + lo] as u16) << hi;
            }
            _ = write!(output, "0x{u:04x}");
        }
        output.push_str("],\n");
    }

    _ = write!(
        output,
        "\
];

#[rustfmt::skip] pub const STRINGS: [&str; {len}] = [
",
        len = assembly.strings.len(),
    );

    for s in assembly.strings {
        _ = writeln!(output, "    {s:?},");
    }

    output.push_str("];\n");

    Ok(output)
}
